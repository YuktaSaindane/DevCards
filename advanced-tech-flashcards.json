{
  "title": "Advanced Full-Stack Development Flashcards",
  "description": "Professional-level React, TypeScript, and modern web development concepts with intuitive explanations",
  "totalCards": 46,
  "topics": [
    "React Performance & Advanced Hooks",
    "TypeScript Advanced Patterns",
    "Performance Optimization",
    "API Design & Architecture",
    "Serverless & Cloud",
    "CI/CD & DevOps",
    "Security & Best Practices",
    "Scalability & Architecture",
    "Testing & Quality",
    "Modern Web Standards",
    "State Management",
    "Advanced JavaScript Concepts",
    "Database & Backend",
    "Interview & Leadership"
  ],
  "flashcards": [
    {
      "question": "How does React's Concurrent Features improve performance?",
      "answer": "Think of it like multitasking on your phone. React can now pause rendering a heavy component (like a complex chart) to handle urgent user input (like typing), then resume the chart later. This prevents the \"frozen\" UI feeling users hate."
    },
    {
      "question": "When would you use useMemo vs useCallback vs React.memo?",
      "answer": "useMemo: Cache expensive calculations (like filtering 10k items). useCallback: Cache functions passed to child components to prevent unnecessary re-renders. React.memo: Wrap components that re-render too often with same props (like a heavy sidebar)."
    },
    {
      "question": "Explain the difference between useLayoutEffect and useEffect.",
      "answer": "useEffect runs AFTER the browser paints (asynchronous). useLayoutEffect runs BEFORE painting (synchronous). Use useLayoutEffect when you need to measure DOM elements or prevent visual flicker - like auto-sizing a tooltip."
    },
    {
      "question": "How would you implement a custom hook for complex state management?",
      "answer": "Example: useApiCall hook that manages loading, data, and errors. Combines useReducer for state logic + useEffect for API calls. Returns { data, loading, error, refetch }. Reusable across components that fetch data."
    },
    {
      "question": "What are React Server Components and their benefits?",
      "answer": "Components that render on the server, sending HTML to browser instead of JavaScript. Benefits: Smaller bundle size (no JS for server components), direct database access, better SEO. Mix with client components for interactive parts."
    },
    {
      "question": "Explain conditional types with a practical example.",
      "answer": "Like an if-statement for types! Example: type ApiResponse<T> = T extends string ? { message: T } : { data: T }. If you pass a string, you get {message}, otherwise {data}. Perfect for flexible API responses."
    },
    {
      "question": "How do mapped types enhance code safety?",
      "answer": "Take an existing type and transform it. Example: type Optional<T> = { [K in keyof T]?: T[K] } makes all properties optional. Like taking a User type and creating OptionalUser automatically - no manual rewriting!"
    },
    {
      "question": "What are template literal types used for?",
      "answer": "Build type-safe strings! Example: type ButtonVariant = `btn-${\"primary\" | \"secondary\"}` creates \"btn-primary\" | \"btn-secondary\". Great for CSS classes, API routes like `/api/${string}/users`."
    },
    {
      "question": "Explain the benefits of const assertions in TypeScript.",
      "answer": "Forces TypeScript to be super specific. const colors = [\"red\", \"blue\"] as const makes it readonly [\"red\", \"blue\"] instead of string[]. Prevents mutations and gives you exact string literals for better autocomplete."
    },
    {
      "question": "How would you optimize a large list with thousands of items?",
      "answer": "Only render what's visible! Use react-window to show ~20 items at a time instead of 10,000. Add pagination (load 50 at a time), proper keys for each item, and memoize expensive list items with React.memo."
    },
    {
      "question": "Explain different code-splitting strategies in React.",
      "answer": "Split your app into chunks: 1) Route-level: Each page loads separately with React.lazy() 2) Component-level: Heavy components load on-demand 3) Vendor splitting: React/libraries separate from your code. Users download only what they need!"
    },
    {
      "question": "What are the core Web Vitals and how to optimize them?",
      "answer": "Google's performance metrics: LCP (how fast main content loads) - optimize images, use CDN. FID (how fast page responds to clicks) - reduce JavaScript blocking. CLS (how much page jumps around) - set image dimensions."
    },
    {
      "question": "How does tree shaking work and how to optimize it?",
      "answer": "Removes unused code from your bundle. Like importing only the functions you need from lodash instead of the whole library. Use ES6 imports, avoid import * from, and build tools automatically eliminate dead code."
    },
    {
      "question": "Design a REST API for a multi-tenant SaaS application.",
      "answer": "Each customer is a \"tenant\". Isolate data by: 1) Subdomain (customer1.yourapp.com) 2) URL path (/api/tenant123/users) 3) Headers. Add role-based permissions, API versioning (/v1/), rate limiting per tenant, and always return proper HTTP codes (200, 404, etc)."
    },
    {
      "question": "When would you choose GraphQL over REST?",
      "answer": "When mobile apps need specific data fields (avoid downloading unnecessary data), you have complex relationships (user → posts → comments), or multiple data sources. GraphQL lets clients request exactly what they need in one query."
    },
    {
      "question": "How do you handle API versioning and backward compatibility?",
      "answer": "Keep old versions running! Example: /v1/users and /v2/users both work. Add deprecation warnings to v1, give clients time to migrate. Use feature flags to gradually roll out changes. Communicate breaking changes early and clearly."
    },
    {
      "question": "Explain microservices communication patterns.",
      "answer": "Like apps talking to each other: 1) Synchronous: Direct HTTP calls for immediate responses (get user info) 2) Asynchronous: Message queues for background tasks (send email after order) 3) API Gateway as the \"front door\" handling auth/routing."
    },
    {
      "question": "What are the trade-offs of serverless architectures?",
      "answer": "PROS: No servers to manage, auto-scales to zero, pay only when code runs. CONS: Cold starts (first request is slow), 15-minute timeout limits, harder to debug, and can get expensive with high traffic. Great for APIs, not for long-running tasks."
    },
    {
      "question": "How do you handle state in serverless functions?",
      "answer": "Functions are stateless - they forget everything after each run. Store data in: databases (PostgreSQL), caches (Redis), or cloud storage (S3). Use environment variables for config, connection pooling for databases."
    },
    {
      "question": "Explain the difference between CDN and Edge Computing.",
      "answer": "CDN: Stores static files (images, CSS) worldwide for fast downloads. Edge Computing: Runs your actual code closer to users. Example: CDN serves your React app, Edge functions handle API calls with low latency."
    },
    {
      "question": "Design a CI/CD pipeline for a React application.",
      "answer": "Automate the flow: Code push → Run tests → Build app → Deploy to staging → Run integration tests → Deploy to production. Use GitHub Actions or Jenkins. Include rollback buttons for when things break!"
    },
    {
      "question": "How do you implement zero-downtime deployments?",
      "answer": "Keep two identical environments (blue/green). Deploy to the inactive one, test it, then switch traffic over. If something breaks, instantly switch back. Users never see downtime or errors."
    },
    {
      "question": "What monitoring and observability tools would you implement?",
      "answer": "Error tracking (Sentry), performance monitoring (DataDog), server logs (ELK stack), user behavior (Google Analytics), uptime checks (Pingdom). Set up alerts when things go wrong - don't wait for users to complain!"
    },
    {
      "question": "How do you prevent XSS attacks in React applications?",
      "answer": "React automatically escapes user input (safe by default). Never use dangerouslySetInnerHTML with user data. Add Content Security Policy headers, validate all inputs on the server, and always use HTTPS."
    },
    {
      "question": "Implement secure authentication with JWT tokens.",
      "answer": "Two-token system: Short access tokens (15 min) for API calls, long refresh tokens (7 days) in httpOnly cookies. When access expires, use refresh to get new access token. Clear both on logout."
    },
    {
      "question": "What are the OWASP Top 10 security risks for web apps?",
      "answer": "Top threats: SQL injection, broken authentication, data exposure, XSS attacks, broken access control, security misconfigurations, using vulnerable components, insufficient logging. Know these for interviews!"
    },
    {
      "question": "How would you scale a React app to handle 1M+ users?",
      "answer": "Multi-layer approach: CDN for global file delivery, code splitting (load pages on demand), caching (Redis), horizontal scaling (multiple servers), database optimization (indexes, read replicas), and break into microservices."
    },
    {
      "question": "Explain different caching strategies for web applications.",
      "answer": "Layer by layer: Browser cache (images, CSS), CDN cache (global), app cache (Redis for data), database cache (query results). Each layer makes things faster and reduces server load."
    },
    {
      "question": "How do you handle real-time features at scale?",
      "answer": "WebSockets for live chat/updates, message brokers (Redis/Kafka) to handle millions of messages, sticky sessions (user stays on same server), and graceful fallback to polling if WebSockets fail."
    },
    {
      "question": "Design a comprehensive testing strategy for a React app.",
      "answer": "Test pyramid: Lots of unit tests (Jest for functions), some component tests (React Testing Library), few integration tests (Cypress for user flows). Add accessibility testing and run automatically on every code push."
    },
    {
      "question": "How do you test custom hooks effectively?",
      "answer": "Use renderHook from @testing-library/react-hooks. Test the hook's return values, different input scenarios, side effects (API calls), and cleanup behavior. Mock external dependencies."
    },
    {
      "question": "What's the difference between shallow and deep rendering in testing?",
      "answer": "Shallow: Renders just the component, not its children (like Enzyme). Deep: Renders the full component tree (React Testing Library default). Deep testing is more realistic - tests what users actually see."
    },
    {
      "question": "Explain Progressive Web App (PWA) essential features.",
      "answer": "Web apps that feel like native apps: Work offline (service workers), can be installed on phone home screen (manifest file), responsive design, secure (HTTPS only). Users get app-like experience without app stores."
    },
    {
      "question": "How do Web Workers improve application performance?",
      "answer": "Run heavy JavaScript in background threads so UI stays responsive. Great for: processing large datasets, image manipulation, cryptography. Main thread handles UI, worker handles computation - no more frozen screens!"
    },
    {
      "question": "What are the benefits of HTTP/2 for web applications?",
      "answer": "Faster web: Multiple requests at once (multiplexing), server can push files before you ask, compressed headers save bandwidth. Basically makes websites load much faster than HTTP/1.1."
    },
    {
      "question": "Compare Redux, Zustand, and Recoil for state management.",
      "answer": "Redux: Most popular, lots of boilerplate but predictable. Zustand: Lightweight, easy to learn. Recoil: Facebook's solution, great for complex apps. Choose Redux for large teams, Zustand for simplicity, Recoil for complex state relationships."
    },
    {
      "question": "When would you use Context vs external state management?",
      "answer": "Context: Simple shared data (theme, user info, language). External tools (Redux/Zustand): Complex logic, frequent updates, time-travel debugging, or when Context causes too many re-renders."
    },
    {
      "question": "Implement optimistic updates in a React application.",
      "answer": "Show success immediately, fix later if needed. Example: Like button turns red instantly, send API request in background. If it fails, show error and revert. Users feel the app is super fast."
    },
    {
      "question": "Explain the difference between Promise.all and Promise.allSettled.",
      "answer": "Promise.all: If ANY promise fails, everything fails (all-or-nothing). Promise.allSettled: Wait for ALL promises to finish, get both successes and failures. Use allSettled when some failures are okay."
    },
    {
      "question": "How do you implement proper error boundaries in React?",
      "answer": "Wrap components in error boundary (class component with componentDidCatch). Catches render errors and shows fallback UI instead of white screen of death. Can't catch async errors or event handler errors though."
    },
    {
      "question": "What are the practical applications of Proxy in JavaScript?",
      "answer": "Intercept and customize object operations. Examples: Vue 3 reactivity (auto-detect data changes), API mocking (fake responses), validation (check values on set), and tracking property access for debugging."
    },
    {
      "question": "How do you handle database migrations in production?",
      "answer": "Very carefully! Make backward-compatible changes, test on staging first, run migrations during low-traffic hours, have rollback plans ready. Never drop columns immediately - deprecate first, remove later."
    },
    {
      "question": "Explain different database scaling strategies.",
      "answer": "Scale up: Bigger, more powerful server (expensive, has limits). Scale out: Multiple servers - read replicas for reads, sharding for writes, caching layer (Redis) to reduce database load."
    },
    {
      "question": "How do you approach technical debt in a growing codebase?",
      "answer": "Track it like bugs - document what needs fixing, prioritize by impact/effort. Fix some during each sprint alongside new features. Do regular code reviews to prevent new debt. Educate team on best practices."
    },
    {
      "question": "Design a system for A/B testing in a React application.",
      "answer": "Feature flags: Show version A to 50% of users, version B to 50%. Track conversion metrics (clicks, signups). Use tools like LaunchDarkly or build simple if/else with user ID hash. Statistical significance matters!"
    },
    {
      "question": "How do you mentor junior developers effectively?",
      "answer": "Pair program together, explain WHY during code reviews (not just what to fix), give them challenging but achievable tasks, encourage questions, and share your thought process for architectural decisions."
    }
  ]
}
